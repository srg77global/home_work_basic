// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package online_shop

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateOrderByUsernameProductnameAndQuantityFirst = `-- name: CreateOrderByUsernameProductnameAndQuantityFirst :one
INSERT INTO orders (user_id, order_date, total_amount)
VALUES ((SELECT id FROM users WHERE name=$1), now(), (SELECT price FROM products WHERE name=$2)*$3)
RETURNING $2
`

type CreateOrderByUsernameProductnameAndQuantityFirstParams struct {
	Column1 *string        `db:"column_1" json:"column_1"`
	Column2 *string        `db:"column_2" json:"column_2"`
	Column3 pgtype.Numeric `db:"column_3" json:"column_3"`
}

func (q *Queries) CreateOrderByUsernameProductnameAndQuantityFirst(ctx context.Context, arg CreateOrderByUsernameProductnameAndQuantityFirstParams) (*string, error) {
	row := q.db.QueryRow(ctx, CreateOrderByUsernameProductnameAndQuantityFirst, arg.Column1, arg.Column2, arg.Column3)
	var column_1 *string
	err := row.Scan(&column_1)
	return column_1, err
}

const CreateOrderByUsernameProductnameAndQuantitySecond = `-- name: CreateOrderByUsernameProductnameAndQuantitySecond :one
INSERT INTO orderProducts (order_id, product_id)
VALUES ((SELECT id FROM orders ORDER BY order_date DESC LIMIT 1), (SELECT id FROM products WHERE name=$1))
RETURNING order_id
`

func (q *Queries) CreateOrderByUsernameProductnameAndQuantitySecond(ctx context.Context, name string) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, CreateOrderByUsernameProductnameAndQuantitySecond, name)
	var order_id pgtype.UUID
	err := row.Scan(&order_id)
	return order_id, err
}

const DeleteOrderByUsername = `-- name: DeleteOrderByUsername :one
DELETE FROM orders
WHERE user_id=(SELECT id FROM users WHERE name=$1)
RETURNING $1
`

func (q *Queries) DeleteOrderByUsername(ctx context.Context, name string) (*string, error) {
	row := q.db.QueryRow(ctx, DeleteOrderByUsername, name)
	var column_1 *string
	err := row.Scan(&column_1)
	return column_1, err
}

const DeleteProductByName = `-- name: DeleteProductByName :one
DELETE FROM products
WHERE name=$1
RETURNING id
`

func (q *Queries) DeleteProductByName(ctx context.Context, name string) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, DeleteProductByName, name)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const DeleteUserByName = `-- name: DeleteUserByName :one
DELETE FROM users
WHERE name=$1
RETURNING id
`

func (q *Queries) DeleteUserByName(ctx context.Context, name string) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, DeleteUserByName, name)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const InsertProduct = `-- name: InsertProduct :one
INSERT INTO products (name, price)
VALUES ($1, $2)
RETURNING id
`

type InsertProductParams struct {
	Name  string         `db:"name" json:"name"`
	Price pgtype.Numeric `db:"price" json:"price"`
}

func (q *Queries) InsertProduct(ctx context.Context, arg InsertProductParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, InsertProduct, arg.Name, arg.Price)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const InsertUser = `-- name: InsertUser :one
INSERT INTO users (name, email, password)
VALUES ($1, $2, $3)
RETURNING id
`

type InsertUserParams struct {
	Name     string `db:"name" json:"name"`
	Email    string `db:"email" json:"email"`
	Password string `db:"password" json:"password"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, InsertUser, arg.Name, arg.Email, arg.Password)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const SelectOrdersByUsername = `-- name: SelectOrdersByUsername :many
SELECT u.name AS user_name, o.order_date, o.total_amount
FROM orders o, users u
WHERE o.user_id = u.id AND u.name=$1
`

type SelectOrdersByUsernameRow struct {
	UserName    string             `db:"user_name" json:"user_name"`
	OrderDate   pgtype.Timestamptz `db:"order_date" json:"order_date"`
	TotalAmount pgtype.Numeric     `db:"total_amount" json:"total_amount"`
}

func (q *Queries) SelectOrdersByUsername(ctx context.Context, name string) ([]*SelectOrdersByUsernameRow, error) {
	rows, err := q.db.Query(ctx, SelectOrdersByUsername, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectOrdersByUsernameRow{}
	for rows.Next() {
		var i SelectOrdersByUsernameRow
		if err := rows.Scan(&i.UserName, &i.OrderDate, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SelectProductsByPrices = `-- name: SelectProductsByPrices :many
SELECT name FROM products
WHERE price > $1 and price < $2
`

type SelectProductsByPricesParams struct {
	Price   pgtype.Numeric `db:"price" json:"price"`
	Price_2 pgtype.Numeric `db:"price_2" json:"price_2"`
}

func (q *Queries) SelectProductsByPrices(ctx context.Context, arg SelectProductsByPricesParams) ([]string, error) {
	rows, err := q.db.Query(ctx, SelectProductsByPrices, arg.Price, arg.Price_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SelectTwoUsersByUsername = `-- name: SelectTwoUsersByUsername :many
SELECT id, name, email, password FROM users
WHERE name=$1 OR name=$2
`

type SelectTwoUsersByUsernameParams struct {
	Name   string `db:"name" json:"name"`
	Name_2 string `db:"name_2" json:"name_2"`
}

func (q *Queries) SelectTwoUsersByUsername(ctx context.Context, arg SelectTwoUsersByUsernameParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, SelectTwoUsersByUsername, arg.Name, arg.Name_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SelectUsersByOrders = `-- name: SelectUsersByOrders :many
SELECT u.name, o.total_amount / p.price AS units_bought
FROM users u, orders o, products p, orderProducts op
WHERE u.id = o.user_id AND o.id = op.order_id AND p.id = op.product_id
`

type SelectUsersByOrdersRow struct {
	Name        string         `db:"name" json:"name"`
	UnitsBought pgtype.Numeric `db:"units_bought" json:"units_bought"`
}

func (q *Queries) SelectUsersByOrders(ctx context.Context) ([]*SelectUsersByOrdersRow, error) {
	rows, err := q.db.Query(ctx, SelectUsersByOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectUsersByOrdersRow{}
	for rows.Next() {
		var i SelectUsersByOrdersRow
		if err := rows.Scan(&i.Name, &i.UnitsBought); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateProductpriceByName = `-- name: UpdateProductpriceByName :one
UPDATE products
SET price=$1
WHERE name=$2
RETURNING id
`

type UpdateProductpriceByNameParams struct {
	Price pgtype.Numeric `db:"price" json:"price"`
	Name  string         `db:"name" json:"name"`
}

func (q *Queries) UpdateProductpriceByName(ctx context.Context, arg UpdateProductpriceByNameParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, UpdateProductpriceByName, arg.Price, arg.Name)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const UpdateUsernameByName = `-- name: UpdateUsernameByName :one
UPDATE users
SET name=$1
WHERE name=$2
RETURNING id
`

type UpdateUsernameByNameParams struct {
	Name   string `db:"name" json:"name"`
	Name_2 string `db:"name_2" json:"name_2"`
}

func (q *Queries) UpdateUsernameByName(ctx context.Context, arg UpdateUsernameByNameParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, UpdateUsernameByName, arg.Name, arg.Name_2)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
